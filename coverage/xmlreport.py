# coding: utf-8
# Licensed under the Apache License: http://www.apache.org/licenses/LICENSE-2.0
# For details: https://github.com/nedbat/coveragepy/blob/master/NOTICE.txt

"""XML reporting for coverage.py"""

import os
import sys
import time
import xml.dom.minidom
from coverage import env
from coverage import __url__, __version__, files
from coverage.backward import iitems
from coverage.misc import isolate_module
from coverage.report import get_analysis_to_report
from coverage.backward import SimpleNamespace

os = isolate_module(os)


DTD_URL = 'https://raw.githubusercontent.com/cobertura/web/master/htdocs/xml/coverage-04.dtd'


def rate(hit, num):
    """Return the fraction of `hit`/`num`, as a string."""
    if num == 0:
        return "1"
    else:
        return "%.4g" % (float(hit) / num)


def convert_to_dict(tup):
    di = {}
    for a, b in tup:
        di.setdefault(a, []).append(b)
    return di

class XmlReporter(object):
    """
        A reporter for writing Cobertura-style XML coverage results.
    """
    EMPTY = "(empty)"
    def __init__(self, coverage, report_name=None):
        self.coverage = coverage
        self.config = self.coverage.config
        #
        self.report_name = report_name
        #
        self.source_paths = set()
        if self.config.source:
            for src in self.config.source:
                if os.path.exists(src):
                    if not self.config.relative_files:
                        src = files.canonical_filename(src)
                    self.source_paths.add(src)
        self.packages = {}
        self.xml_out = None
        self.is_class_level = False

    def report(self, morfs=None, outfile=None):
        """
            Generate a Cobertura-compatible XML report for `morfs`.

            `morfs` is a list of modules or file names.

            `outfile` is a file object to write the XML to.

        """
        # Initial setup.
        outfile = outfile or sys.stdout
        has_arcs = self.coverage.get_data().has_arcs()

        # Create the DOM that will store the data.
        impl = xml.dom.minidom.getDOMImplementation()
        self.xml_out = impl.createDocument(None, "coverage", None)

        # Write header stuff.
        xcoverage = self.xml_out.documentElement
        xcoverage.setAttribute("version", __version__)
        xcoverage.setAttribute("timestamp", str(int(time.time()*1000)))
        xcoverage.appendChild(self.xml_out.createComment(" Generated by coverage.py: %s " % __url__))
        xcoverage.appendChild(self.xml_out.createComment(" Based on %s " % DTD_URL))

        # Call xml_file for each file in the data.
        for fr, analysis in get_analysis_to_report(self.coverage, morfs):
            self.xml_file(fr, analysis, has_arcs)

        xsources = self.xml_out.createElement("sources")
        xcoverage.appendChild(xsources)

        # Populate the XML DOM with the source info.
        for path in sorted(self.source_paths):
            xsource = self.xml_out.createElement("source")
            xsources.appendChild(xsource)
            txt = self.xml_out.createTextNode(path)
            xsource.appendChild(txt)

        lnum_tot, lhits_tot = 0, 0
        bnum_tot, bhits_tot = 0, 0

        xpackages = self.xml_out.createElement("packages")
        xcoverage.appendChild(xpackages)

        # Populate the XML DOM with the package info.
        for pkg_name, pkg_data in sorted(iitems(self.packages)):
            modules_elts, lhits, lnum, bhits, bnum = pkg_data
            xpackage = self.xml_out.createElement("package")
            xpackages.appendChild(xpackage)

            xclasses = self.xml_out.createElement("classes")
            xpackage.appendChild(xclasses)
            #
            for _, (class_elts, fn_elts) in sorted(iitems(modules_elts)):
                for class_elt in class_elts:
                    xclasses.appendChild(class_elt)
                #
                for fn in fn_elts:
                    xpackage.appendChild(fn)

            xpackage.setAttribute("name", pkg_name.replace(os.sep, '.'))
            xpackage.setAttribute("line-rate", rate(lhits, lnum))
            xpackage.setAttribute("hits", str(lhits))
            xpackage.setAttribute("lines", str(lnum))
            branch_rate = rate(bhits, bnum) if has_arcs else "0"
            xpackage.setAttribute("branch-rate", branch_rate)
            xpackage.setAttribute("complexity", "0")

            lnum_tot += lnum
            lhits_tot += lhits
            bnum_tot += bnum
            bhits_tot += bhits

        xcoverage.setAttribute("lines-valid", str(lnum_tot))
        xcoverage.setAttribute("lines-covered", str(lhits_tot))
        xcoverage.setAttribute("line-rate", rate(lhits_tot, lnum_tot))
        if has_arcs:
            xcoverage.setAttribute("branches-valid", str(bnum_tot))
            xcoverage.setAttribute("branches-covered", str(bhits_tot))
            xcoverage.setAttribute("branch-rate", rate(bhits_tot, bnum_tot))
        else:
            xcoverage.setAttribute("branches-covered", "0")
            xcoverage.setAttribute("branches-valid", "0")
            xcoverage.setAttribute("branch-rate", "0")
        xcoverage.setAttribute("complexity", "0")

        #
        if self.report_name:
            xcoverage.setAttribute("name", self.report_name)
        # Write the output file.
        outfile.write(serialize_xml(self.xml_out))

        # Return the total percentage.
        denom = lnum_tot + bnum_tot
        pct = 0.0 if denom == 0 else 100.0 * (lhits_tot + bhits_tot) / denom
        return pct


    def is_property_tag(self, tokens_list):
        tokens = convert_to_dict(tokens_list)
        key = tokens.get('op', [''])[0]
        nam = tokens.get('nam', [''])[0]
        #
        is_tag = key == '@'
        if is_tag:
            if nam in ['staticmethod', 'classmethod']:
                self.is_class_level = True
        #
        return is_tag


    def is_member_fn(self, tokens):
        for token, value in tokens:
            if token == 'nam' and (value in ['self', 'cls']):
                return True
        return False


    def process_tokens(self, tokens_list, tag):
        tokens = convert_to_dict(tokens_list)
        key = tokens.get('key', [''])[0]
        name = tokens.get('nam', [''])[0]
        if key == tag:
            return True, name
        return False, None


    def extract_names(self, fr):
        filename = fr.filename.replace("\\", "/")
        for source_path in self.source_paths:
            source_path = files.canonical_filename(source_path)
            if filename.startswith(source_path.replace("\\", "/") + "/"):
                rel_name = filename[len(source_path)+1:]
                break
        else:
            rel_name = fr.relative_filename()
            self.source_paths.add(fr.filename[:-len(rel_name)].rstrip(r"\/"))

        dirname = os.path.dirname(rel_name) or u"."
        dirname = "/".join(dirname.split("/")[:self.config.xml_package_depth])
        return dirname, rel_name


    def create_class(self, name, rel_name, lineno):
        xclass = self.xml_out.createElement("class")
        xclass.setAttribute("name", name)
        xclass.setAttribute("filename", rel_name.replace("\\", "/"))
        xclass.setAttribute("complexity", "0")
        xclass.first_line = lineno
        return xclass

    def set_class_stats(self, xclass, end_line, analysis):
        first_line = xclass.first_line
        filtered = [smt for smt in analysis.statements if smt >=first_line and smt <=end_line]
        class_lines = len(filtered)
        xclass.setAttribute("lines", str(class_lines))
        class_hits = 0

        filtered_missing = [smt for smt in analysis.missing if smt >=first_line and smt <=end_line]
        #
        class_hits = class_lines - len(filtered_missing)
        xclass.setAttribute("hits", str(class_hits))

        # Finalize the statistics that are collected in the XML DOM.
        xclass.setAttribute("line-rate", rate(class_hits, class_lines))

    def set_method_stats(self, xmethod):
        method_hits = 0
        method_misses = 0
        for child in xmethod.childNodes:
            if child.getAttribute('hits') == "1":
                method_hits += 1
            else:
                method_misses += 1
        #
        method_lines = len(xmethod.childNodes)
        xmethod.setAttribute("lines", str(method_lines))
        xmethod.setAttribute("hits", str(method_hits))
        xmethod.setAttribute("misses", str(method_misses))

    def process_class(self, rel_name, lineno, tokens, xclass, xmethod, analysis):
        found, name = self.process_tokens(tokens, "class")
        if found:
            #
            if xclass:
                if xmethod:
                    xclass.appendChild(xmethod)
                #
                last_line = lineno
                for smt in analysis.statements:
                    if smt < lineno:
                        last_line = smt
                #
                self.set_class_stats(xclass, last_line, analysis)
            #
            xclass = self.create_class(name, rel_name, lineno)
            return True, xclass
        #
        return False, xclass

    def process_method(self, xmethod, tokens, xclass, free_fn, rel_name):
        found, method_name = self.process_tokens(tokens, "def")
        if found:
            #
            if xmethod:
                self.set_method_stats(xmethod)
            #
            xmethod = self.xml_out.createElement("method")
            xmethod.setAttribute("name", method_name)
            if xclass and (self.is_member_fn(tokens) or self.is_class_level):
                xclass.appendChild(xmethod)
                self.is_class_level = False
            else:
                filename = rel_name.replace("\\", "/")
                xmethod.setAttribute("filename", filename)
                free_fn.append(xmethod)
            return True, xmethod
        return False, xmethod

    def mount_package(self, dirname):
        package_name = dirname.replace("/", ".")
        package = self.packages.setdefault(package_name, [{}, 0, 0, 0, 0])
        return package

    def process_line(self, line, has_arcs, branch_stats, missing_branch_arcs, analysis):
        # Processing Line
        xline = self.xml_out.createElement("line")
        xline.setAttribute("number", str(line))
        # Q: can we get info about the number of times a statement is
        # executed?  If so, that should be recorded here.
        is_hit = (line not in analysis.missing)
        xline.setAttribute("hits", str(int(is_hit)))
        if has_arcs:
            if line in branch_stats:
                total, taken = branch_stats[line]
                xline.setAttribute("branch", "true")
                xline.setAttribute(
                    "condition-coverage",
                    "%d%% (%d/%d)" % (100*taken//total, taken, total)
                )
            if line in missing_branch_arcs:
                annlines = ["exit" if b < 0 else str(b) for b in missing_branch_arcs[line]]
                xline.setAttribute("missing-branches", ",".join(annlines))
        return xline

    def xml_file(self, fr, analysis, has_arcs):
        """Add to the XML report for a single file."""
        if self.config.skip_empty and analysis.numbers.n_statements == 0:
            return

        #
        dirname, rel_name = self.extract_names(fr)
        package = self.mount_package(dirname)
        # Free functions
        free_fn = []

        #
        xclasses = []
        xclass, xmethod = None, None
        branch_stats = analysis.branch_stats()
        missing_branch_arcs = analysis.missing_branch_arcs()

        line = 1
        self.is_class_level = False
        for line, tokens in enumerate(fr.source_token_lines(), start=1):
            if line not in analysis.statements:
                continue

            if tokens:
                is_tag = self.is_property_tag(tokens)
                if is_tag:
                    continue
                # We found a new class definition?
                created, xclass = self.process_class(rel_name, line, tokens, xclass, xmethod, analysis)
                if created:
                    xclasses.append(xclass)
                    continue
                #
                created, xmethod = self.process_method(xmethod, tokens, xclass, free_fn, rel_name)
                if created:
                    if not self.is_class_level and xclass:
                        self.set_class_stats(xclass, line, analysis)
                    continue
                #
                # Processing a line
                xline = self.process_line(line, has_arcs, branch_stats, missing_branch_arcs, analysis)
                if xmethod:
                    xmethod.appendChild(xline)
                elif xclass:
                    xclass.appendChild(xline)
        #
        if xclass and self.is_class_level:
            self.set_class_stats(xclass, line, analysis)
        if xmethod:
            self.set_method_stats(xmethod)

        # Rename
        package[0][rel_name] = (xclasses, free_fn)
        if has_arcs:
            classes_branches = sum(t for t, k in branch_stats.values())
            missing_branches = sum(t - k for t, k in branch_stats.values())
            classes_br_hits = classes_branches - missing_branches
        else:
            classes_branches = 0.0
            classes_br_hits = 0.0
        #
        classes_lines = len(analysis.statements)
        classes_hits = classes_lines - len(analysis.missing)
        #
        package[1] += classes_hits
        package[2] += classes_lines
        package[3] += classes_br_hits
        package[4] += classes_branches




def serialize_xml(dom):
    """Serialize a minidom node to XML."""
    out = dom.toprettyxml()
    if env.PY2:
        out = out.encode("utf8")
    return out
